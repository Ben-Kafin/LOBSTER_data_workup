# -*- coding: utf-8 -*-
"""
Created on Tue Mar 18 18:41:08 2025

@author: Benjamin Kafin
"""
from __future__ import annotations

import collections
import fnmatch
import itertools
import os
import re
import warnings
from collections import defaultdict
from typing import TYPE_CHECKING, cast

import numpy as np
from monty.dev import deprecated
from monty.io import zopen
from monty.json import MSONable

from pymatgen.core.structure import Structure
from pymatgen.electronic_structure.bandstructure import LobsterBandStructureSymmLine
from pymatgen.electronic_structure.core import Orbital, Spin
from pymatgen.electronic_structure.dos import Dos, LobsterCompleteDos
from pymatgen.io.vasp.inputs import Kpoints
from pymatgen.io.vasp.outputs import Vasprun, VolumetricData
from pymatgen.util.due import Doi, due
from pymatgen.util.typing import PathLike

if TYPE_CHECKING:
    from typing import Any, ClassVar, Literal

    from numpy.typing import NDArray

    from pymatgen.core.structure import IStructure
    from pymatgen.electronic_structure.cohp import IcohpCollection
    from pymatgen.util.typing import Tuple3Ints, Vector3D

import re
import numpy as np
from monty.io import zopen
from pymatgen.electronic_structure.core import Orbital, Spin
from pymatgen.util.typing import PathLike
from pymatgen.core.structure import Structure
from pymatgen.electronic_structure.dos import Dos, LobsterCompleteDos
from numpy.typing import NDArray
from collections import defaultdict
from typing import Any


class Cohpcar:
    """Read COXXCAR.lobster/COXXCAR.LCFO.lobster files generated by LOBSTER with LCFO fragments support."""

    def __init__(
        self,
        are_coops: bool = False,
        are_cobis: bool = False,
        are_multi_center_cobis: bool = False,
        is_lcfo: bool = False,
        filename: PathLike | None = None,
        lcfo_fragments_path: PathLike | None = None,  # New parameter for LCFO fragments
    ) -> None:
        """
        Args:
            are_coops (bool): Whether the file includes COOPs (True) or COHPs (False).
            are_cobis (bool): Whether the file is COBIs (True) or COHPs (False).
            are_multi_center_cobis (bool): Whether the file includes multi-center COBIs (True).
            is_lcfo (bool): Whether the COXXCAR file is from LCFO analysis.
            filename (PathLike): The COHPCAR file. If it is None, the default
                file name will be chosen, depending on the value of are_coops.
            lcfo_fragments_path (PathLike): Path to the LCFO_fragments file to map fragments to atoms/groups.
        """
        # Ensure only one file type is being processed
        if (
            (are_coops and are_cobis)
            or (are_coops and are_multi_center_cobis)
            or (are_cobis and are_multi_center_cobis)
        ):
            raise ValueError("You cannot have info about COOPs, COBIs and/or multi-center COBIS in the same file.")

        self.are_coops = are_coops
        self.are_cobis = are_cobis
        self.are_multi_center_cobis = are_multi_center_cobis
        self.is_lcfo = is_lcfo
        self._filename = filename

        # Default filename handling
        if self._filename is None:
            if are_coops:
                self._filename = "COOPCAR.lobster"
            elif are_cobis or are_multi_center_cobis:
                self._filename = "COBICAR.lobster"
            else:
                self._filename = "COHPCAR.lobster"

        # Parse LCFO fragments if a path is provided
        self.lcfo_fragments = None
        if is_lcfo and lcfo_fragments_path:
            self.lcfo_fragments = self._parse_lcfo_fragments(lcfo_fragments_path)

        # Read and process the COHPCAR file
        with zopen(self._filename, mode="rt", encoding="utf-8") as file:
            lines = file.read().split("\n")

        parameters = lines[1].split()
        num_bonds = int(parameters[0]) if self.are_multi_center_cobis else int(parameters[0]) - 1
        self.efermi = float(parameters[-1])
        self.is_spin_polarized = int(parameters[1]) == 2
        spins = [Spin.up, Spin.down] if self.is_spin_polarized else [Spin.up]

        # Prepare COHP data
        cohp_data: dict[str, dict[str, Any]] = {}
        if not self.are_multi_center_cobis:
            data = np.array([np.array(line.split(), dtype=float) for line in lines[num_bonds + 3 :]]).transpose()
            cohp_data = {
                "average": {
                    "COHP": {spin: data[1 + 2 * s * (num_bonds + 1)] for s, spin in enumerate(spins)},
                    "ICOHP": {spin: data[2 + 2 * s * (num_bonds + 1)] for s, spin in enumerate(spins)},
                }
            }

        # Initialize COHP and orbital-resolved COHP structures
        self.energies = data[0]
        orb_cohp: dict[str, Any] = {}
        bond_num = 0
        bond_data = {}

        for bond in range(num_bonds):
            bond_data = self._get_bond_data(
                lines[3 + bond],
                is_lcfo=self.is_lcfo,
                lcfo_fragments=self.lcfo_fragments,
            )
            label = str(bond_num)
            orbs = bond_data["orbitals"]

            cohp = {spin: data[2 * (bond + s * (num_bonds + 1)) + 3] for s, spin in enumerate(spins)}
            icohp = {spin: data[2 * (bond + s * (num_bonds + 1)) + 4] for s, spin in enumerate(spins)}

            if orbs is None:
                bond_num += 1
                label = str(bond_num)
                cohp_data[label] = {
                    "COHP": cohp,
                    "ICOHP": icohp,
                    "length": bond_data["length"],
                    "sites": bond_data["sites"],
                }
            elif label in orb_cohp:
                orb_cohp[label] |= {
                    bond_data["orb_label"]: {
                        "COHP": cohp,
                        "ICOHP": icohp,
                        "orbitals": orbs,
                        "length": bond_data["length"],
                        "sites": bond_data["sites"],
                    }
                }
            else:
                bond_num += 1
                label = str(bond_num)
                orb_cohp[label] = {
                    bond_data["orb_label"]: {
                        "COHP": cohp,
                        "ICOHP": icohp,
                        "orbitals": orbs,
                        "length": bond_data["length"],
                        "sites": bond_data["sites"],
                    }
                }

        self.orb_res_cohp = orb_cohp or None
        self.cohp_data = cohp_data

    @staticmethod
    def _get_bond_data(line, is_lcfo, lcfo_fragments=None):
        """
        Extract bond label, site indices, and length, mapping LCFO fragment names if needed.
        """
        line_new = line.rsplit("(", 1)
        length = float(line_new[-1][:-1])
        sites = line_new[0].replace("->", ":").split(":")[1:3]

        # Map LCFO fragment names to original atom names if LCFO fragments are provided
        if lcfo_fragments:
            sites = [lcfo_fragments.get(site.split("[")[0], site) for site in sites]

        if "[" in sites[0]:
            orbs = [re.findall(r"\[(.*)\]", site)[0] for site in sites]
            orb_label = "-".join(orbs)
            orbitals = orbs
        else:
            orbitals = None
            orb_label = None

        return {
            "length": length,
            "sites": sites,
            "orbitals": orbitals,
            "orb_label": orb_label,
        }

    @staticmethod
    def _parse_lcfo_fragments(fragment_file_path):
        """
        Parse LCFO fragments to map fragment names to atom names or groups.
        """
        fragments = {}
        current_fragment = None

        with open(fragment_file_path, "r") as f:
            for line in f:
                line = line.strip()
                if line.startswith("Atoms forming fragment"):
                    current_fragment = line.split()[3]
                    fragments[current_fragment] = []
                elif current_fragment and line:
                    fragments[current_fragment].append(line.split()[0])

        return fragments


class Doscar:
    """Store LOBSTER's projected DOS and local projected DOS, modified to support LCFO analysis."""

    def __init__(
        self,
        doscar: PathLike = "DOSCAR.lobster",
        is_lcfo: bool = False,
        structure_file: PathLike | None = "POSCAR",
        structure: Structure | None = None,
        lcfo_fragments_path: PathLike | None = None,  # New parameter for LCFO fragments
    ) -> None:
        """
        Args:
            doscar (PathLike): The DOSCAR file, typically "DOSCAR.lobster".
            is_lcfo (bool): Whether the DOSCAR file is from LCFO analysis.
            structure_file (PathLike): For VASP, this is typically "POSCAR".
            structure (Structure): Instead of a structure file (preferred),
                the Structure can be given directly.
            lcfo_fragments_path (PathLike): Path to the LCFO_fragments file to map fragments to atoms/groups.
        """
        self._doscar = doscar
        self._is_lcfo = is_lcfo

        self._final_structure = Structure.from_file(structure_file) if structure_file is not None else structure

        # Parse the LCFO fragments if applicable
        self.lcfo_fragments = None
        if is_lcfo and lcfo_fragments_path:
            self.lcfo_fragments = self._parse_lcfo_fragments(lcfo_fragments_path)

        self._parse_doscar()

    def _parse_lcfo_fragments(self, fragment_file_path):
        """
        Parse the LCFO_fragments file to create a mapping of fragment numbers to atom or group names.
        
        Args:
            fragment_file_path (PathLike): Path to the LCFO_fragments file.
        
        Returns:
            dict: A mapping of fragment numbers to atom names or groups.
        """
        fragments = {}
        current_fragment = None

        with open(fragment_file_path, "r") as f:
            for line in f:
                line = line.strip()
                if line.startswith("Atoms forming fragment"):
                    # Extract the fragment number
                    current_fragment = line.split()[3]
                    fragments[current_fragment] = []
                elif current_fragment and line:
                    # Add atom names to the current fragment
                    fragments[current_fragment].append(line.split()[0])

        return fragments

    def _map_fragments_to_orbitals(self, orbitals):
        """
        Map fragment numbers in orbital labels to their corresponding atoms/groups.
        
        Args:
            orbitals (list): List of orbitals with fragment numbers.
        
        Returns:
            list: Updated orbital labels with fragment names or original labels.
        """
        if not self.lcfo_fragments:
            return orbitals
        
        mapped_orbitals = []
        for orbital in orbitals:
            # Extract the fragment number from the orbital label (e.g., "1a" -> "1")
            fragment_number = re.match(r"(\d+)[a-zA-Z]*", orbital)
            if fragment_number:
                fragment_number = fragment_number.group(1)
                if fragment_number in self.lcfo_fragments:
                    mapped_orbitals.append(f"Fragment_{fragment_number}({','.join(self.lcfo_fragments[fragment_number])})")
                else:
                    mapped_orbitals.append(orbital)
            else:
                mapped_orbitals.append(orbital)

        return mapped_orbitals

    def _parse_doscar(self):
        """
        Parse the DOSCAR.lcfo file to extract TDOS, molecular orbital (MO)-resolved PDOS, and metadata.
        """
        tdensities = {}
        itdensities = {}
        pdoss = []
    
        with zopen(self._doscar, mode="rt", encoding="utf-8") as file:
            lines = file.readlines()
    
        # Validate file content
        if len(lines) < 6:
            raise ValueError("DOSCAR.lcfo file does not contain sufficient lines for parsing.")
    
        # Extract Fermi energy from the sixth line (fourth number listed)
        try:
            efermi = float(lines[5].split()[3])  # Sixth line, fourth number
        except (IndexError, ValueError) as e:
            raise ValueError("Failed to extract Fermi energy. Check DOSCAR.lcfo file format.") from e
    
        print(f"Extracted Fermi energy: {efermi}")
    
        # Parse TDOS and metadata
        tdos_data = []
        pdos_start = None
        mo_labels = None  # Store molecular orbital labels
    
        for i, line in enumerate(lines[6:], start=6):
            if not line.strip():  # Empty line marks the start of the PDOS section
                pdos_start = i + 1
                break
    
            # Handle header line with metadata (MO labels)
            if ";" in line:
                numerical_part, metadata_part = line.split(";", 1)
    
                # Parse molecular orbital labels
                metadata_split = metadata_part.split(";")
                fragment_metadata = metadata_split[0].strip()  # Example: "C13N2H18"
                mo_labels = metadata_split[1].strip().split()  # Example: ["1a", "2a", ...]
    
                print(f"Fragment: {fragment_metadata}, MO Labels: {mo_labels}")
    
            else:
                numerical_part = line
    
            # Parse numerical part into TDOS data
            try:
                row = [float(x) for x in numerical_part.split()]
                print(f"Parsed TDOS row {i}: {row}")
    
                # Dynamically check for valid TDOS row length
                if len(row) in [3, 5]:  # Non-spin or spin-polarized TDOS
                    tdos_data.append(row)
                else:
                    print(f"Skipping invalid TDOS row {i} (unexpected number of columns): {row}")
            except ValueError:
                print(f"Skipping invalid TDOS row {i} (contains non-numeric values): {line.strip()}")
    
        if len(tdos_data) == 0:
            raise ValueError("No valid TDOS data found in the DOSCAR.lcfo file.")
    
        tdos_data = np.array(tdos_data)
        energies = tdos_data[:, 0]
        self._is_spin_polarized = tdos_data.shape[1] == 5
    
        # Parse PDOS block starting after the empty line
        if pdos_start:
            current_pdos = defaultdict(dict)
    
            for line in lines[pdos_start:]:
                try:
                    pdos_values = [float(x) for x in line.split()]
                    if not mo_labels:  # Ensure MO labels are present
                        print(f"Warning: MO labels are missing for PDOS at line {line.strip()}")
                        continue
    
                    # Assign contributions to molecular orbitals
                    for j, mo_label in enumerate(mo_labels):
                        if mo_label not in current_pdos:
                            current_pdos[mo_label] = {Spin.up: np.zeros_like(energies)}
    
                        # Assuming rows correspond to MO PDOS data:
                        current_pdos[mo_label][Spin.up] = np.array(pdos_values[j::len(mo_labels)])
                except ValueError:
                    print(f"Skipping invalid PDOS row: {line.strip()}")
    
            pdoss.append(current_pdos)
    
        # Assign attributes
        self._efermi = efermi
        self._energies = energies
        self._tdos = Dos(efermi, energies, tdensities)
        self._pdos = pdoss



    @property
    def completedos(self) -> LobsterCompleteDos:
        """LobsterCompleteDos."""
        return self._completedos

    @property
    def pdos(self) -> list[dict]:
        """Projected DOS (PDOS)."""
        return self._pdos

    @property
    def tdos(self) -> Dos:
        """Total DOS (TDOS)."""
        return self._tdos

    @property
    def energies(self) -> NDArray:
        """Energies."""
        return self._energies

    @property
    def tdensities(self) -> dict[Spin, NDArray]:
        """Total DOS densities."""
        return self._tdensities

    @property
    def itdensities(self) -> dict[Spin, NDArray]:
        """Integrated TDOS densities."""
        return self._itdensities

    @property
    def is_spin_polarized(self) -> bool:
        """Check if the system is spin-polarized."""
        return self._is_spin_polarized


# Enhanced Icohplist class with full support for LCFO and orbital-wise files
class Icohplist(MSONable):
    """Read ICOXXLIST/ICOXXLIST.LCFO.lobster files generated by LOBSTER.

    Extended to handle standard, LCFO, orbital-wise, and LCFO + orbital-wise formats.
    """
    def __init__(
        self,
        is_lcfo: bool = False,
        are_coops: bool = False,
        are_cobis: bool = False,
        filename: PathLike | None = None,
        is_spin_polarized: bool = False,
        orbitalwise: bool = False,
        icohpcollection: IcohpCollection | None = None,
    ) -> None:
        """
        Initialize the Icohplist class.

        Args:
            is_lcfo (bool): Whether the ICOHPLIST file is from LCFO analysis.
            are_coops (bool): Whether the file includes COOPs (True) or COHPs (False).
            are_cobis (bool): Whether the file is COBIs (True) or COHPs (False).
            filename (PathLike): Path to the ICOHPLIST file.
            is_spin_polarized (bool): Whether the calculation is spin polarized.
            orbitalwise (bool): Whether the calculation is orbital-wise.
            icohpcollection (IcohpCollection): IcohpCollection object for compatibility.
        """
        super().__init__()
        self._filename = filename
        self.is_lcfo = is_lcfo
        self.is_spin_polarized = is_spin_polarized
        self.orbitalwise = orbitalwise
        self.are_coops = are_coops
        self.are_cobis = are_cobis
        self._icohpcollection = icohpcollection
        self.icohplist = {}  # Parsed data stored here
        self._parse_file()  # Parse the file during initialization

    def _parse_file(self):
        """Parse the ICOHPLIST file and detect its format."""
        with zopen(self._filename, mode="rt", encoding="utf-8") as file:
            all_lines = file.readlines()

        # Detect format
        self._detect_format(all_lines)

        # Parse based on format
        if self.is_lcfo and self.orbitalwise:
            self._parse_lcfo_orbitalwise(all_lines)
        elif self.is_lcfo:
            self._parse_lcfo(all_lines)
        elif self.orbitalwise:
            self._parse_orbitalwise(all_lines)
        else:
            self._parse_standard(all_lines)

    def _detect_format(self, lines):
        """Detect the file format."""
        header = lines[0].strip().split()
        # Check for LCFO-specific columns
        self.is_lcfo = "fragmentAlpha" in header and "fragmentBeta" in header
        # Check for orbital-specific data
        self.orbitalwise = any("_" in col for col in lines[1].strip().split())
        # Determine spin polarization
        self.is_spin_polarized = any("spin 2" in line for line in lines[:10])

    def _parse_standard(self, lines):
        """Parse non-LCFO and non-orbital-wise ICOHP files dynamically for one or two spins."""
        # Skip the first two header lines
        data_lines = lines[2:]
    
        for line in data_lines:
            tokens = line.strip().split()
    
            # Ensure line has enough tokens to process
            if len(tokens) < 8:  # At least 8 tokens needed for minimal valid data
                print(f"Skipping malformed line: {line.strip()}")
                continue
    
            try:
                bond_index = tokens[0]  # COHP#
                atom1 = tokens[1]       # atomMU
                atom2 = tokens[2]       # atomNU
                bond_length = float(tokens[3])  # distance
    
                # Skip translation vectors (tokens[4], tokens[5], tokens[6])
                translation = tokens[4:7]  # Save translation vectors for later use, if needed
    
                # Determine if the file includes one or two spins
                if len(tokens) == 8:  # Only one spin value present
                    icohp_spin1 = float(tokens[7])  # ICOHP for spin 1
                    icohp_spin2 = None  # No spin 2 value
                elif len(tokens) == 9:  # Two spin values present
                    icohp_spin1 = float(tokens[7])  # ICOHP for spin 1
                    icohp_spin2 = float(tokens[8])  # ICOHP for spin 2
                else:
                    print(f"Unexpected token count in line: {line.strip()}")
                    continue
    
                # Create the ICOHP entry
                icohp_entry = {
                    "atomMU": atom1,
                    "atomNU": atom2,
                    "length": bond_length,
                    "translation": translation,  # Optional; can be omitted if not needed
                    "icohp": {"spin1": icohp_spin1, "spin2": icohp_spin2},
                }
                self.icohplist[bond_index] = icohp_entry
                print(f"Parsed entry {bond_index}: {icohp_entry}")
    
            except ValueError as e:
                print(f"Error parsing line: {line.strip()} - {e}")
                continue

    def _parse_orbitalwise(self, lines, top_contributors=3):
        """Parse orbital-wise ICOHP files dynamically."""
        current_bond = None
        orbital_contributions = {}
    
        # Skip the first two header lines
        data_lines = lines[2:]
    
        for line in data_lines:
            tokens = line.strip().split()
    
            # Ensure line has enough tokens to process
            if len(tokens) < 8:  # At least 8 tokens needed for minimal valid data
                print(f"Skipping malformed line: {line.strip()}")
                continue
    
            try:
                # Detect bond index
                if tokens[0].startswith("COHP#"):
                    current_bond = tokens[0].split("#")[1]
                    continue
    
                orbital1 = tokens[1]
                orbital2 = tokens[2]
                bond_length = float(tokens[3])
                icohp_spin1 = float(tokens[7])
                icohp_spin2 = float(tokens[8]) if self.is_spin_polarized else None
    
                # If this is the first line for the bond index, treat as atomic ICOHP
                if current_bond not in self.icohplist:
                    # Save atomic ICOHP entry
                    atomic_entry = {
                        "atomMU": orbital1,
                        "atomNU": orbital2,
                        "length": bond_length,
                        "translation": tokens[4:7],
                        "icohp": {"spin1": icohp_spin1, "spin2": icohp_spin2},
                        "orbital_contributions": [],  # Placeholder for orbital contributions
                    }
                    self.icohplist[current_bond] = atomic_entry
                else:
                    # Save individual orbital interaction under current bond index
                    orbital_entry = {
                        "orbitalMU": orbital1,
                        "orbitalNU": orbital2,
                        "length": bond_length,
                        "translation": tokens[4:7],
                        "icohp": {"spin1": icohp_spin1, "spin2": icohp_spin2},
                    }
                    if current_bond not in orbital_contributions:
                        orbital_contributions[current_bond] = []
                    orbital_contributions[current_bond].append(orbital_entry)
            except ValueError as e:
                print(f"Error parsing line: {line.strip()} - {e}")
                continue
    
        # Calculate top orbital contributors for each bond index
        for bond_index, orbitals in orbital_contributions.items():
            if bond_index not in self.icohplist:
                continue  # Skip bonds without atomic ICOHP entries
    
            # Retrieve total atomic ICOHP
            total_atomic_icohp = self.icohplist[bond_index]["icohp"]["spin1"]
    
            # Calculate closeness to total atomic ICOHP
            contributions = [
                {
                    "interaction": f"{entry['orbitalMU']} - {entry['orbitalNU']}",
                    "icohp": entry["icohp"]["spin1"],
                    "difference": abs(entry["icohp"]["spin1"] - total_atomic_icohp),
                }
                for entry in orbitals
            ]
    
            # Sort by closeness to the atomic ICOHP
            contributions = sorted(contributions, key=lambda x: x["difference"])
    
            # Keep only the top contributors
            top_contributions = contributions[:top_contributors]
    
            # Save top contributions in atomic entry
            self.icohplist[bond_index]["orbital_contributions"] = top_contributions
    
            print(f"Processed bond {bond_index} with top contributions: {top_contributions}")


    def _parse_lcfo(self, lines):
        """Parse LCFO ICOHP files dynamically for fragments, skipping translation vectors."""
        # Skip the first two header lines, consistent with standard format
        data_lines = lines[2:]
    
        for line in data_lines:
            tokens = line.strip().split()
    
            # Ensure line has enough tokens to process
            if len(tokens) < 8:  # At least 8 tokens needed for minimal valid data
                print(f"Skipping malformed line: {line.strip()}")
                continue
    
            try:
                bond_index = tokens[0]  # COHP#
                fragment1 = tokens[1]  # Fragment Alpha
                fragment2 = tokens[2]  # Fragment Beta
                bond_length = float(tokens[3])  # Distance
    
                # Skip translation vectors (tokens[4], tokens[5], tokens[6])
                translation = tokens[4:7]  # Save translation vectors for context or discard
    
                # Determine if the file includes one or two spins
                if len(tokens) == 8:  # Only one spin value present
                    icohp_spin1 = float(tokens[7])  # ICOHP for spin 1
                    icohp_spin2 = None  # No spin 2 value
                elif len(tokens) == 9:  # Two spin values present
                    icohp_spin1 = float(tokens[7])  # ICOHP for spin 1
                    icohp_spin2 = float(tokens[8])  # ICOHP for spin 2
                else:
                    print(f"Unexpected token count in line: {line.strip()}")
                    continue
    
                # Create the ICOHP entry
                icohp_entry = {
                    "fragmentAlpha": fragment1,
                    "fragmentBeta": fragment2,
                    "length": bond_length,
                    "translation": translation,  # Optional; can be omitted if not needed
                    "icohp": {"spin1": icohp_spin1, "spin2": icohp_spin2},
                }
                self.icohplist[bond_index] = icohp_entry
                print(f"Parsed entry {bond_index}: {icohp_entry}")
    
            except ValueError as e:
                print(f"Error parsing line: {line.strip()} - {e}")
                continue




    def _parse_lcfo_orbitalwise(self, lines):
        """Parse LCFO + orbital-wise ICOHP files."""
        current_bond = None
        for line in lines[1:]:
            tokens = line.strip().split()
    
            # Skip invalid or malformed lines
            if len(tokens) < 6 or not tokens[3].replace(".", "", 1).isdigit():
                continue
    
            if tokens[0].startswith("COHP#"):
                current_bond = tokens[0].split("#")[1]
                continue
    
            fragment1 = tokens[1]
            orbital2 = tokens[2]
            bond_length = float(tokens[3])
            icohp_spin1 = float(tokens[4])  # Spin 1 value
            icohp_spin2 = float(tokens[5]) if self.is_spin_polarized else None  # Spin 2 value if polarized
            icohp_entry = {
                "fragmentAlpha": fragment1,
                "orbitalBeta": orbital2,
                "length": bond_length,
                "icohp": {"spin1": icohp_spin1, "spin2": icohp_spin2},
            }
            if current_bond not in self.icohplist:
                self.icohplist[current_bond] = {"fragment_orbital_interactions": []}
            self.icohplist[current_bond]["fragment_orbital_interactions"].append(icohp_entry)

